// Generated by CoffeeScript 1.6.3
var painter,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

painter = {
  applyCanvasOptions: function(type, context, options) {
    if (type === 'fill') {
      if (__indexOf.call(options, 'color') >= 0) {
        return context.fillStyle = options.color;
      }
    } else if (type === 'stroke') {
      if (__indexOf.call(options, 'color') >= 0) {
        context.strokeStyle = options.color;
      }
      if (__indexOf.call(options, 'width') >= 0) {
        return context.lineWidth = options.width;
      }
    }
  },
  fillCircle: function(context, position, radius, options) {
    if (radius == null) {
      radius = 2;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('fill', context, options);
    context.beginPath();
    context.arc(position.x, position.y, radius, 0, 2 * Math.PI, true);
    context.fill();
    return ctx.closePath();
  },
  drawCircle: function(context, position, radius, options) {
    if (radius == null) {
      radius = 2;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('stroke', context, options);
    context.beginPath();
    context.arc(position.x, position.y, radius, 0, 2 * Math.PI, true);
    return context.stroke();
  },
  drawLine: function(context, p1, p2, options) {
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('stroke', context, options);
    context.strokeStyle = color;
    context.lineWidth = lineWidth;
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    return context.stroke();
  },
  drawTriangle: function(context, p1, p2, p3, options) {
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('stroke', context, options);
    context.strokeStyle = color;
    context.lineWidth = lineWidth;
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    context.lineTo(p3.x, p3.y);
    context.closePath();
    return context.stroke();
  },
  drawCenteredPolygon: function(context, center, points, angle, options) {
    var point, _i, _len, _ref;
    if (angle == null) {
      angle = 0;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('stroke', context, options);
    context.beginPath();
    context.moveTo(points[0].x, points[0].y);
    _ref = points.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      context.lineTo(point.x, point.y);
    }
    context.closePath();
    return context.fill();
  },
  drawPolygon: function(context, points, options) {
    var point, _i, _len, _ref;
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('stroke', context, options);
    context.beginPath();
    context.moveTo(points[0].x, points[0].y);
    _ref = points.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      context.lineTo(point.x, point.y);
    }
    context.lineTo(points[0].x, points[0].y);
    context.closePath();
    return context.fill();
  },
  drawRectangle: function(context, p1, p2, options) {
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('stroke', context, options);
    context.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p2.y);
    return context.stroke();
  },
  fillRectangle: function(context, p1, p2, angle, options) {
    if (angle == null) {
      angle = 0;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('fill', context, options);
    if (angle) {
      context.save();
      context.translate((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
      context.rotate(angle);
      context.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
      return context.restore();
    } else {
      return context.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
    }
  },
  fillCenteredRect: function(context, point, size, options) {
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions('fill', context, options);
    context.fillStyle = color;
    if (angle) {
      context.save();
      context.translate(point.x, point.y);
      context.rotate(angle);
      context.fillRect(-size.x / 2, -size.y / 2, size.x, size.y);
      return context.restore();
    } else {
      return context.fillRect(point.x - size.x / 2, point.y - size.y / 2, size.x, size.y);
    }
  }
};
