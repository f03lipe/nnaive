// Generated by CoffeeScript 1.6.3
var Board, Bot, Circle, Drawable, FixedPole, Square, Triangle, getResultant, mm, painter, xy, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

painter = {
  fillCircle: function(context, position, radius, color) {
    if (radius == null) {
      radius = 2;
    }
    if (color == null) {
      color = "black";
    }
    context.fillStyle = color;
    context.beginPath();
    context.arc(position.x, position.y, radius, 0, 2 * Math.PI, true);
    return context.fill();
  },
  drawCircle: function(context, position, radius, color) {
    if (radius == null) {
      radius = 2;
    }
    if (color == null) {
      color = "black";
    }
    context.strokeStyle = color;
    context.beginPath();
    context.arc(position.x, position.y, radius, 0, 2 * Math.PI, true);
    return context.stroke();
  },
  drawLine: function(context, p1, p2, lineWidth, color) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    context.strokeStyle = color;
    context.lineWidth = lineWidth;
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    return context.stroke();
  },
  drawTriangle: function(context, p1, p2, p3, lineWidth, color) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    context.strokeStyle = color;
    context.lineWidth = lineWidth;
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    context.lineTo(p3.x, p3.y);
    context.lineTo(p1.x, p1.y);
    return context.stroke();
  },
  drawPolygon: function(context, points, lineWidth, color) {
    var point, _i, _len, _ref;
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    context.fillStyle = '#F00';
    context.beginPath();
    context.moveTo(points[0].x, points[0].y);
    _ref = points.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      context.lineTo(point.x, point.y);
    }
    context.lineTo(points[0].x, points[0].y);
    context.closePath();
    return context.fill();
  },
  drawRectangle: function(context, p1, p2, lineWidth, color) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    context.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p2.y);
    return context.stroke();
  },
  fillRectangle: function(context, point, size, color, angle) {
    if (color == null) {
      color = "black";
    }
    if (angle == null) {
      angle = 0;
    }
    context.fillStyle = color;
    if (angle) {
      context.save();
      context.translate(point.x, point.y);
      context.rotate(angle);
      context.fillRect(-size / 2, -size / 2, size, size);
      return context.restore();
    } else {
      return context.fillRect(point.x - size / 2, point.y - size / 2, size, size);
    }
  }
};

mm = function(min, num, max) {
  return Math.max(min, Math.min(max, num));
};

xy = function(x, y) {
  return {
    x: x,
    y: y
  };
};

getResultant = function(m, objects) {
  var F, alpha, d2, dfx, dfy, dx, dy, fx, fy, multiplier, obj, rx, ry, _i, _len;
  fx = fy = 0;
  for (_i = 0, _len = objects.length; _i < _len; _i++) {
    obj = objects[_i];
    if (!(obj !== m)) {
      continue;
    }
    dx = m.position.x - obj.position.x;
    dy = m.position.y - obj.position.y;
    rx = dx > 0 ? -1 : 1;
    ry = dy > 0 ? -1 : 1;
    d2 = Math.pow(m.position.x - obj.position.x, 2) + Math.pow(m.position.y - obj.position.y, 2);
    F = 1 / d2;
    painter.drawLine(context, m.position, obj.position, mm(0, F * 5000, 200), "grey");
    alpha = Math.atan(dy / dx);
    dfx = Math.abs(Math.cos(alpha)) * F * rx;
    dfy = Math.abs(Math.sin(alpha)) * F * ry;
    multiplier = m.getMultiplier(obj);
    if (d2 < Math.pow(obj.size + m.size, 2)) {
      dfx = -dfx;
      dfy = -dfy;
    }
    fx += dfx * multiplier;
    fy += dfy * multiplier;
  }
  painter.drawLine(context, m.position, {
    x: m.position.x + fx * 10000,
    y: m.position.y + fy * 10000
  }, 1, "red");
  return {
    x: fx,
    y: fy
  };
};

Drawable = (function() {
  Drawable.prototype.type = 'Drawable';

  Drawable.prototype.multipliers = {};

  Drawable.prototype.mass = 1;

  Drawable.prototype.position = {
    x: null,
    y: null
  };

  Drawable.prototype.velocity = {
    x: null,
    y: null
  };

  Drawable.prototype.acceleration = {
    x: null,
    y: null
  };

  Drawable.prototype.shift = {
    x: null,
    y: null
  };

  Drawable.prototype.angle = 0;

  Drawable.prototype.angularSpeed = 0;

  function Drawable(position) {
    this.position = position;
    this.velocity = {
      x: 0,
      y: 0
    };
    this.acceleration = {
      x: 0,
      y: 0
    };
  }

  Drawable.prototype.getMultiplier = function(obj) {
    console.log('getting', obj.type, this.multipliers);
    return this.multipliers[obj.type] || 1;
  };

  Drawable.prototype.tic = function(step) {
    var avg_acceleration;
    step = 20;
    this._acceleration = {
      x: this.acceleration.x,
      y: this.acceleration.y
    };
    this.position.x += this.velocity.x * step + (0.5 * this._acceleration.x * step * step);
    this.position.y += this.velocity.y * step + (0.5 * this._acceleration.y * step * step);
    this.acceleration = getResultant(this, game.board.state);
    this.acceleration.x *= 1 / this.mass;
    this.acceleration.y *= 1 / this.mass;
    avg_acceleration = {
      x: (this._acceleration.x + this.acceleration.x) / 2,
      y: (this._acceleration.y + this.acceleration.y) / 2
    };
    this.velocity.x += avg_acceleration.x * step * window.vars.rest / 10;
    this.velocity.y += avg_acceleration.y * step * window.vars.rest / 10;
    this.angle += this.angularSpeed * step * Math.min(this.velocity.x * this.velocity.y, 2) / this.mass;
    this.position.x = mm(0, this.position.x, window.canvas.width);
    return this.position.y = mm(0, this.position.y, window.canvas.height);
  };

  Drawable.prototype.render = function(context) {};

  return Drawable;

})();

Triangle = (function(_super) {
  __extends(Triangle, _super);

  Triangle.p1 = Triangle.p2 = Triangle.p3 = null;

  function Triangle(position) {
    this.position = position;
    this.p1 = {
      x: -60 * Math.random(),
      y: -60 * Math.random()
    };
    this.p2 = {
      x: 60 * Math.random(),
      y: 60 * Math.random()
    };
    this.p3 = {
      x: 60 * Math.random(),
      y: 60 * Math.random()
    };
  }

  Triangle.prototype.setPoints = function(p1, p2, p3) {
    this.p1 = p1;
    this.p2 = p2;
    this.p3 = p3;
  };

  Triangle.prototype.tic = function(step) {};

  Triangle.prototype.render = function(context) {
    var _p1, _p2, _p3;
    _p1 = {
      x: this.p1.x + this.position.x,
      y: this.p1.y + this.position.y
    };
    _p2 = {
      x: this.p2.x + this.position.x,
      y: this.p2.y + this.position.y
    };
    _p3 = {
      x: this.p3.x + this.position.x,
      y: this.p3.y + this.position.y
    };
    return painter.drawTriangle(context, _p1, _p2, _p3);
  };

  return Triangle;

})(Drawable);

Circle = (function(_super) {
  __extends(Circle, _super);

  Circle.size = null;

  function Circle(position, size) {
    this.position = position;
    this.size = size != null ? size : 20;
  }

  Circle.prototype.render = function(context) {
    return painter.drawCircle(context, this.position, this.size);
  };

  return Circle;

})(Drawable);

window.lastAdded = null;

Square = (function(_super) {
  __extends(Square, _super);

  Square.prototype.type = 'Square';

  Square.prototype.endPoint = null;

  Square.prototype.color = "black";

  Square.prototype.size = 15;

  function Square(position) {
    this.position = position;
    this.render = __bind(this.render, this);
    Square.__super__.constructor.apply(this, arguments);
  }

  Square.prototype.render = function(context) {
    var vertex1, vertex2;
    vertex1 = {
      x: this.position.x - this.size,
      y: this.position.y - this.size
    };
    vertex2 = {
      x: this.position.x + this.size,
      y: this.position.y + this.size
    };
    return painter.fillRectangle(context, this.position, this.size, this.color, this.angle);
  };

  return Square;

})(Drawable);

Bot = (function(_super) {
  __extends(Bot, _super);

  Bot.prototype.type = 'Bot';

  Bot.prototype.multipliers = [
    {
      'Bot': -2,
      'FixedPole': -1
    }
  ];

  Bot.prototype.color = "red";

  Bot.angularSpeed = 0.002;

  function Bot(position) {
    this.position = position;
    Bot.__super__.constructor.apply(this, arguments);
    window.lastAdded = this;
  }

  Bot.prototype.tic = function(step) {
    Bot.__super__.tic.apply(this, arguments);
    if (this === window.lastAdded) {
      return console.log;
    }
  };

  return Bot;

})(Square);

FixedPole = (function(_super) {
  __extends(FixedPole, _super);

  function FixedPole() {
    _ref = FixedPole.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  FixedPole.color = "#08e";

  FixedPole.prototype.tic = function(step) {};

  return FixedPole;

})(Circle);

Board = (function() {
  Board.prototype.addObject = function(object) {
    return this.state.push(object);
  };

  function Board(canvas) {
    var name, vars, _i, _len;
    this.canvas = canvas;
    window.context = this.canvas.getContext("2d");
    window.vars = {};
    vars = ['rest'];
    for (_i = 0, _len = vars.length; _i < _len; _i++) {
      name = vars[_i];
      window.vars[name] = $(".control#" + name + " input").attr('value');
      $(".control#" + name + " input").bind('change', function(event) {
        var value;
        value = Math.max(0.1, event.target.value / 100);
        event.target.parentElement.querySelector('span').innerHTML = value;
        return window.vars[name] = value;
      });
    }
    this.state = [];
  }

  Board.prototype.render = function(context) {
    var item, _i, _len, _ref1, _results;
    _ref1 = this.state;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      _results.push(item.render(context));
    }
    return _results;
  };

  Board.prototype.tic = function(step) {
    var item, _i, _len, _ref1, _results;
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    _ref1 = this.state;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      _results.push(item.tic(step));
    }
    return _results;
  };

  return Board;

})();
