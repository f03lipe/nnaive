// Generated by CoffeeScript 1.6.3
var Board, Bot, Circle, Drawable, FixedPole, Food, Square, Triangle, dist, dist2, getResultant, mm, mod, painter, _ref, _ref1, _ref2, _ref3,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

mod = function(a, n) {
  return ((a % n) + n) % n;
};

dist2 = function(a, b) {
  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);
};

dist = function(a, b) {
  return Math.sqrt(dist2(a, b));
};

painter = {
  applyCanvasOptions: function(context, options) {
    if (options.fill === true) {
      return context.fillStyle = options.color || 'black';
    } else {
      context.strokeStyle = options.color || 'blue';
      return context.lineWidth = options.width || 1;
    }
  },
  drawCircle: function(context, position, radius, options) {
    if (radius == null) {
      radius = 2;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions(context, options);
    context.beginPath();
    context.arc(position.x, position.y, radius, 0, 2 * Math.PI, true);
    if (options.fill) {
      return context.fill();
    } else {
      return context.stroke();
    }
  },
  drawLine: function(context, p1, p2, options) {
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions(context, options);
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    return context.stroke();
  },
  drawTriangle: function(context, p1, p2, p3, options) {
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions(context, options);
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    context.lineTo(p3.x, p3.y);
    context.closePath();
    return context.stroke();
  },
  drawCenteredPolygon: function(context, center, points, angle, options) {
    var point, _i, _len, _ref;
    if (angle == null) {
      angle = 0;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions(context, options);
    context.save();
    context.translate(center.x, center.y);
    context.rotate(angle);
    context.beginPath();
    context.moveTo(points[0].x, points[0].y);
    _ref = points.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      context.lineTo(point.x, point.y);
    }
    context.closePath();
    if (options.fill) {
      context.fill();
    } else {
      context.stroke();
    }
    return context.restore();
  },
  drawPolygon: function(context, points, options) {
    var point, _i, _len, _ref;
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions(context, options);
    context.beginPath();
    context.moveTo(points[0].x, points[0].y);
    _ref = points.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      context.lineTo(point.x, point.y);
    }
    context.lineTo(points[0].x, points[0].y);
    context.closePath();
    if (options.fill) {
      return context.fill();
    } else {
      return context.stroke;
    }
  },
  drawRectangle: function(context, p1, p2, angle, options) {
    if (angle == null) {
      angle = 0;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions(context, options);
    context.beginPath();
    if (angle !== 0) {
      context.save();
      context.translate((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
      context.rotate(angle);
      context.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
      context.restore();
    } else {
      context.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
    }
    if (options.fill) {
      return context.fill();
    } else {
      return context.stroke();
    }
  },
  drawSizedRect: function(context, point, size, angle, options) {
    if (angle == null) {
      angle = 0;
    }
    if (options == null) {
      options = {};
    }
    this.applyCanvasOptions(context, options);
    context.beginPath();
    if (angle) {
      context.save();
      context.translate(point.x, point.y);
      context.rotate(angle);
      context.rect(-size.x / 2, -size.y / 2, size.x, size.y);
      context.restore();
    } else {
      context.rect(point.x - size.x / 2, point.y - size.y / 2, size.x, size.y);
    }
    if (options.fill) {
      return context.fill();
    } else {
      return context.stroke();
    }
  }
};

mm = function(min, num, max) {
  return Math.max(min, Math.min(max, num));
};

getResultant = function(m, objects, distDecay, reppel) {
  var F, alpha, d2, dfx, dfy, fx, fy, multiplier, obj, _i, _len;
  if (distDecay == null) {
    distDecay = 2;
  }
  if (reppel == null) {
    reppel = 2;
  }
  fx = fy = 0;
  for (_i = 0, _len = objects.length; _i < _len; _i++) {
    obj = objects[_i];
    if (!(obj !== m)) {
      continue;
    }
    d2 = Math.pow(m.position.x - obj.position.x, 2) + Math.pow(m.position.y - obj.position.y, 2);
    F = m.mass * obj.mass / (distDecay === 2 ? d2 : Math.pow(d2, distDecay / 2));
    alpha = Math.atan2(m.position.y - obj.position.y, m.position.x - obj.position.x);
    dfx = -Math.cos(alpha) * F;
    dfy = -Math.sin(alpha) * F;
    painter.drawLine(context, m.position, obj.position, {
      color: "#444",
      width: mm(0, F * 50000, 100)
    });
    multiplier = m.getMultiplier(obj);
    if (d2 < Math.pow(obj.size + m.size, 2)) {
      fx += -Math.pow(reppel, 1) * dfx;
      fy += -Math.pow(reppel, 1) * dfy;
    } else {
      fx += dfx * multiplier;
      fy += dfy * multiplier;
    }
  }
  painter.drawLine(context, m.position, {
    x: m.position.x + fx * Math.pow(500000, 1),
    y: m.position.y + fy * Math.pow(500000, 1)
  }, {
    color: "red"
  });
  return {
    x: fx,
    y: fy,
    angle: (fx ? Math.atan(fy / fx) : 0) + (fx < 0 ? Math.PI : 0)
  };
};

Drawable = (function() {
  Drawable.prototype.type = 'Drawable';

  Drawable.prototype.multipliers = {};

  Drawable.prototype.mass = 1;

  Drawable.prototype.angle = 0;

  Drawable.prototype.position = {
    x: 0,
    y: 0
  };

  Drawable.prototype.angularSpeed = 0;

  function Drawable(position) {
    this.position = position != null ? position : null;
    if (this.position === null) {
      this.position = {
        x: Math.floor(Math.random() * canvas.width),
        y: Math.floor(Math.random() * canvas.height)
      };
    }
    this.vel = {
      x: 0,
      y: 0
    };
    this.acc = {
      x: 0,
      y: 0
    };
    this.twalk = 0;
    this.angle = Math.random() * Math.PI * 2;
    this.defineWalk();
    this.thrust = {
      a: .2,
      b: .2,
      c: .2,
      d: .2
    };
    this.factor = {
      x: Math.random() > (typeof 0.5 === "function" ? 0.5({
        1: -1,
        y: Math.random() > (typeof 0.5 === "function" ? 0.5({
          1: -1
        }) : void 0)
      }) : void 0)
    };
  }

  Drawable.prototype.getMultiplier = function(obj) {
    if (obj.type in this.multipliers) {
      return this.multipliers[obj.type];
    }
    return 1;
  };

  Drawable.prototype.defineWalk = function() {};

  Drawable.prototype.ticTT = function(step) {
    var factor, wholevel;
    step = window.vars.step;
    this._acc = {
      x: this.acc.x,
      y: this.acc.y
    };
    this.position.x += this.vel.x * step + (0.5 * this._acc.x * step * step);
    this.position.y += this.vel.y * step + (0.5 * this._acc.y * step * step);
    this.acc = getResultant(this, game.board.state, 2, 4);
    this.acc.x *= 1 / this.mass;
    this.acc.y *= 1 / this.mass;
    factor = step * window.vars.rest / 100;
    this.vel.x += (this._acc.x + this.acc.x) / 2 * factor;
    this.vel.y += (this._acc.y + this.acc.y) / 2 * factor;
    wholevel = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
    this.vel.x = 1 * this.vel.x + 0.01 * wholevel * Math.cos(this.angle);
    this.vel.y = 1 * this.vel.y + 0.01 * wholevel * Math.sin(this.angle);
    if (!this.twalk--) {
      this.defineWalk();
    }
    this.angle += (this.acc.angle - this.angle) * 0.2;
    this.position.x = mm(0, this.position.x, window.canvas.width);
    return this.position.y = mm(0, this.position.y, window.canvas.height);
  };

  Drawable.prototype.render = function(context) {};

  return Drawable;

})();

Triangle = (function(_super) {
  __extends(Triangle, _super);

  function Triangle() {
    _ref = Triangle.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Triangle.prototype.render = function(context) {
    this.p1 = {
      x: 0,
      y: -1.154700 * this.size
    };
    this.p2 = {
      x: -this.size,
      y: 0.5773 * this.size
    };
    this.p3 = {
      x: this.size,
      y: 0.5773 * this.size
    };
    return painter.drawCenteredPolygon(context, this.position, [this.p1, this.p2, this.p3], this.angle, {
      color: this.color
    });
  };

  return Triangle;

})(Drawable);

Circle = (function(_super) {
  __extends(Circle, _super);

  function Circle() {
    _ref1 = Circle.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  Circle.prototype.color = "black";

  Circle.prototype.size = 10;

  Circle.prototype.render = function(context) {
    painter.drawCircle(context, this.position, this.size, {
      color: '#0D8',
      fill: true
    });
    this.p1 = {
      x: this.size / 2,
      y: 0
    };
    this.p2 = {
      x: -this.size * 2 / 3,
      y: this.size / 3
    };
    this.p3 = {
      x: -this.size * 2 / 3,
      y: -this.size / 3
    };
    return painter.drawCenteredPolygon(context, this.position, [this.p1, this.p2, this.p3], this.angle, {
      color: 'white',
      fill: true
    });
  };

  return Circle;

})(Drawable);

window.lastAdded = null;

Square = (function(_super) {
  __extends(Square, _super);

  function Square() {
    this.render = __bind(this.render, this);
    _ref2 = Square.__super__.constructor.apply(this, arguments);
    return _ref2;
  }

  Square.prototype.color = "black";

  Square.prototype.size = 15;

  Square.prototype.render = function(context) {
    return painter.drawSizedRect(context, this.position, {
      x: this.size,
      y: this.size
    }, this.angle, {
      color: this.color,
      fill: true
    });
  };

  return Square;

})(Drawable);

Food = (function(_super) {
  __extends(Food, _super);

  Food.prototype.size = 5;

  function Food() {
    Food.__super__.constructor.apply(this, arguments);
    this.angularSpeed = Math.random() * 20 - 10;
  }

  Food.prototype.tic = function(step) {
    return this.angle += this.angularSpeed * step;
  };

  Food.prototype.eat = function(eater) {
    return this.position = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };
  };

  return Food;

})(Triangle);

Bot = (function(_super) {
  __extends(Bot, _super);

  Bot.prototype.type = 'Bot';

  Bot.prototype.color = '#A2A';

  Bot.prototype.size = 10;

  function Bot(position) {
    this.position = position;
    Bot.__super__.constructor.apply(this, arguments);
    window.lastAdded = this;
  }

  Bot.prototype.tic = function(step) {
    var food, speed, _i, _len, _ref3;
    step = window.vars.step;
    speed = 0.2;
    this.position.x += speed * Math.cos(this.angle) * step;
    this.position.y += speed * Math.sin(this.angle) * step;
    this.position.x = mod(this.position.x, window.canvas.width);
    this.position.y = mod(this.position.y, window.canvas.height);
    _ref3 = game.board.food;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      food = _ref3[_i];
      if (dist2(this.position, food.position) < Math.pow(this.size + food.size, 2)) {
        food.eat(this);
      }
    }
    if (window.leftPressed) {
      this.angle += 0.2;
    }
    if (window.rightPressed) {
      return this.angle -= 0.2;
    }
  };

  Bot.prototype.render = function(context) {
    var a, angles, t;
    Bot.__super__.render.apply(this, arguments);
    context.lineWidth = this.size - 6;
    angles = {
      a: [Math.PI, Math.PI * 3 / 2],
      d: [Math.PI / 2, Math.PI],
      c: [0, Math.PI / 2],
      b: [Math.PI * 3 / 2, 0]
    };
    context.save();
    context.translate(this.position.x, this.position.y);
    context.rotate(this.angle);
    for (t in angles) {
      a = angles[t];
      context.beginPath();
      context.strokeStyle = "rgba(0,0,0," + this.thrust[t] + ")";
      context.arc(0, 0, this.size / 2 + 6, a[0], a[1]);
      context.stroke();
    }
    return context.restore();
  };

  return Bot;

})(Circle);

FixedPole = (function(_super) {
  __extends(FixedPole, _super);

  function FixedPole() {
    _ref3 = FixedPole.__super__.constructor.apply(this, arguments);
    return _ref3;
  }

  FixedPole.prototype.type = 'FixedPole';

  FixedPole.prototype.color = "#08e";

  FixedPole.prototype.size = 30;

  FixedPole.prototype.angularSpeed = .02;

  FixedPole.prototype.tic = function(step) {
    step = 20;
    this.size = window.vars.polesize;
    return this.angle += this.angularSpeed * step;
  };

  return FixedPole;

})(Triangle);

Board = (function() {
  Board.prototype.addObject = function(object) {
    return this.state.push(object);
  };

  Board.prototype.addBot = function(object) {
    return this.bots.push(object);
  };

  Board.prototype.addFood = function(object) {
    return this.food.push(object);
  };

  function Board(canvas) {
    var i, name, vars, _fn, _i, _j, _len;
    this.canvas = canvas;
    window.context = this.canvas.getContext("2d");
    window.frame = 0;
    window.vars = {};
    vars = _.map($(".control"), function(i) {
      return i.id;
    });
    _fn = function() {
      var n,
        _this = this;
      n = name;
      return $(".control#" + name + " input").bind('change', function(event) {
        var value;
        window.e = event;
        value = Math.max(0.1, parseInt(event.target.value) / parseInt(event.target.dataset.divisor || 1));
        event.target.parentElement.querySelector('span').innerHTML = value;
        return window.vars[n] = value;
      });
    };
    for (_i = 0, _len = vars.length; _i < _len; _i++) {
      name = vars[_i];
      window.vars[name] = parseInt($(".control#" + name + " input").attr('value'));
      _fn();
    }
    this.state = [];
    this.bots = [];
    this.food = [];
    for (i = _j = 0; _j <= 50; i = ++_j) {
      this.addFood(new Food());
    }
  }

  Board.prototype.render = function(context) {
    var item, _i, _j, _k, _len, _len1, _len2, _ref4, _ref5, _ref6, _results;
    _ref4 = this.state;
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      item = _ref4[_i];
      item.render(context);
    }
    _ref5 = this.food;
    for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
      item = _ref5[_j];
      item.render(context);
    }
    _ref6 = this.bots;
    _results = [];
    for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
      item = _ref6[_k];
      _results.push(item.render(context));
    }
    return _results;
  };

  Board.prototype.tic = function(step) {
    var item, _i, _j, _k, _len, _len1, _len2, _ref4, _ref5, _ref6, _results;
    window.frame++;
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    _ref4 = this.state;
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      item = _ref4[_i];
      item.tic(step);
    }
    _ref5 = this.food;
    for (_j = 0, _len1 = _ref5.length; _j < _len1; _j++) {
      item = _ref5[_j];
      item.tic(step);
    }
    _ref6 = this.bots;
    _results = [];
    for (_k = 0, _len2 = _ref6.length; _k < _len2; _k++) {
      item = _ref6[_k];
      _results.push(item.tic(step));
    }
    return _results;
  };

  return Board;

})();
