// Generated by CoffeeScript 1.6.3
var Board, Bot, Circle, Drawable, FixedPole, Square, Triangle, getResultant, mm, painter, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

painter = {
  fillCircle: function(context, position, radius, color) {
    if (radius == null) {
      radius = 2;
    }
    if (color == null) {
      color = "black";
    }
    context.fillStyle = color;
    context.beginPath();
    context.arc(position.x, position.y, radius, 0, 2 * Math.PI, true);
    return context.fill();
  },
  drawCircle: function(context, position, radius, color) {
    if (radius == null) {
      radius = 2;
    }
    if (color == null) {
      color = "black";
    }
    context.strokeStyle = color;
    context.beginPath();
    context.arc(position.x, position.y, radius, 0, 2 * Math.PI, true);
    return context.stroke();
  },
  drawLine: function(context, p1, p2, lineWidth, color) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    context.strokeStyle = color;
    context.lineWidth = lineWidth;
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    return context.stroke();
  },
  drawTriangle: function(context, p1, p2, p3, lineWidth, color) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    context.strokeStyle = color;
    context.lineWidth = lineWidth;
    context.beginPath();
    context.moveTo(p1.x, p1.y);
    context.lineTo(p2.x, p2.y);
    context.lineTo(p3.x, p3.y);
    context.lineTo(p1.x, p1.y);
    return context.stroke();
  },
  drawPolygon: function(context, points, lineWidth, color, angle) {
    var point, _i, _len, _ref;
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    if (angle == null) {
      angle = 0;
    }
    context.fillStyle = '#F00';
    context.beginPath();
    context.moveTo(points[0].x, points[0].y);
    _ref = points.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      context.lineTo(point.x, point.y);
    }
    context.lineTo(points[0].x, points[0].y);
    context.closePath();
    return context.fill();
  },
  drawRectangle: function(context, p1, p2, lineWidth, color) {
    if (lineWidth == null) {
      lineWidth = 1;
    }
    if (color == null) {
      color = "black";
    }
    context.rect(p1.x, p1.y, p2.x - p1.x, p2.y - p2.y);
    return context.stroke();
  },
  fillRectangle: function(context, p1, p2, color, angle) {
    if (color == null) {
      color = "black";
    }
    if (angle == null) {
      angle = 0;
    }
    context.fillStyle = color;
    if (angle) {
      context.save();
      context.translate(point.x, point.y);
      context.rotate(angle);
      context.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
      return context.restore();
    } else {
      return context.fillRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
    }
  },
  fillCenteredRect: function(context, point, size, color, angle) {
    if (color == null) {
      color = "black";
    }
    if (angle == null) {
      angle = 0;
    }
    context.fillStyle = color;
    if (angle) {
      context.save();
      context.translate(point.x, point.y);
      context.rotate(angle);
      context.fillRect(-size.x / 2, -size.y / 2, size.x, size.y);
      return context.restore();
    } else {
      return context.fillRect(point.x - size.x / 2, point.y - size.y / 2, size.x, size.y);
    }
  }
};

mm = function(min, num, max) {
  return Math.max(min, Math.min(max, num));
};

getResultant = function(m, objects, distDecay, reppel) {
  var F, alpha, d2, dfx, dfy, dx, dy, fx, fy, multiplier, obj, rx, ry, _i, _len;
  if (distDecay == null) {
    distDecay = 2;
  }
  if (reppel == null) {
    reppel = 2;
  }
  fx = fy = 0;
  for (_i = 0, _len = objects.length; _i < _len; _i++) {
    obj = objects[_i];
    if (!(obj !== m)) {
      continue;
    }
    dx = m.position.x - obj.position.x;
    dy = m.position.y - obj.position.y;
    rx = dx > 0 ? -1 : 1;
    ry = dy > 0 ? -1 : 1;
    d2 = Math.pow(m.position.x - obj.position.x, 2) + Math.pow(m.position.y - obj.position.y, 2);
    F = 1 / (distDecay === 2 ? d2 : Math.pow(d2, distDecay / 2));
    alpha = Math.atan(dy / dx);
    dfx = Math.abs(Math.cos(alpha)) * F * rx;
    dfy = Math.abs(Math.sin(alpha)) * F * ry;
    painter.drawLine(context, m.position, obj.position, mm(0, F * 5000, 200), "grey");
    multiplier = m.getMultiplier(obj);
    if (d2 < Math.pow(obj.size + m.size, 2) * 2) {
      dfx = -reppel * dfx;
      dfy = -reppel * dfy;
    }
    fx += dfx * multiplier;
    fy += dfy * multiplier;
  }
  painter.drawLine(context, m.position, {
    x: m.position.x + fx * 10000,
    y: m.position.y + fy * 10000
  }, 1, "red");
  return {
    x: fx,
    y: fy,
    angle: Math.atan(dy / dx)
  };
};

Drawable = (function() {
  Drawable.prototype.type = 'Drawable';

  Drawable.prototype.multipliers = {};

  Drawable.prototype.mass = 1;

  Drawable.prototype.position = {
    x: null,
    y: null
  };

  Drawable.prototype.velocity = {
    x: null,
    y: null
  };

  Drawable.prototype.acceleration = {
    x: null,
    y: null
  };

  Drawable.prototype.shift = {
    x: null,
    y: null
  };

  Drawable.prototype.angle = 0;

  Drawable.prototype.angularSpeed = 0;

  Drawable.prototype.twalk = 0;

  function Drawable(position) {
    var angle;
    this.position = position;
    this.vel = {
      x: 0,
      y: 0
    };
    this.acc = {
      x: 0,
      y: 0
    };
    angle = Math.random() * Math.PI * 2;
    this.vel.x = (Math.random() > (typeof 0.5 === "function" ? 0.5({
      1: -1
    }) : void 0)) * 100 * Math.random();
    this.defineWalk();
  }

  Drawable.prototype.getMultiplier = function(obj) {
    return this.multipliers[obj.type] || 1;
  };

  Drawable.prototype.defineWalk = function() {
    var max;
    console.log('Defining twalk.');
    max = 0.1;
    this.vel.x = max * Math.random() - max / 2;
    this.vel.y = max * Math.random() - max / 2;
    return this.twalk = Math.max(100, 200 * Math.random());
  };

  Drawable.prototype.tic = function(step) {
    var wholevel;
    step = 200;
    this._acc = {
      x: this.acc.x,
      y: this.acc.y
    };
    this.position.x += this.vel.x * step + (0.5 * this._acc.x * step * step);
    this.position.y += this.vel.y * step + (0.5 * this._acc.y * step * step);
    this.acc = getResultant(this, game.board.state);
    this.acc.x *= 1 / this.mass;
    this.acc.y *= 1 / this.mass;
    this.vel.x += (this._acc.x + this.acc.x) / 2 * step * window.vars.rest / 1000;
    this.vel.y += (this._acc.y + this.acc.y) / 2 * step * window.vars.rest / 1000;
    wholevel = Math.sqrt(this.vel.x * this.vel.x + this.vel.y * this.vel.y);
    this.vel.x = wholevel * Math.cos(this.angle);
    this.vel.y = wholevel * Math.sin(this.angle);
    if (!this.twalk--) {
      this.defineWalk();
    }
    this.angle += this.angularSpeed * step;
    this.position.x = mm(0, this.position.x, window.canvas.width);
    return this.position.y = mm(0, this.position.y, window.canvas.height);
  };

  Drawable.prototype.render = function(context) {};

  return Drawable;

})();

Triangle = (function(_super) {
  __extends(Triangle, _super);

  Triangle.p1 = Triangle.p2 = Triangle.p3 = null;

  function Triangle(position) {
    this.position = position;
    this.p1 = {
      x: -60 * Math.random(),
      y: -60 * Math.random()
    };
    this.p2 = {
      x: 60 * Math.random(),
      y: 60 * Math.random()
    };
    this.p3 = {
      x: 60 * Math.random(),
      y: 60 * Math.random()
    };
  }

  Triangle.prototype.setPoints = function(p1, p2, p3) {
    this.p1 = p1;
    this.p2 = p2;
    this.p3 = p3;
  };

  Triangle.prototype.tic = function(step) {};

  Triangle.prototype.render = function(context) {
    var _p1, _p2, _p3;
    _p1 = {
      x: this.p1.x + this.position.x,
      y: this.p1.y + this.position.y
    };
    _p2 = {
      x: this.p2.x + this.position.x,
      y: this.p2.y + this.position.y
    };
    _p3 = {
      x: this.p3.x + this.position.x,
      y: this.p3.y + this.position.y
    };
    return painter.drawTriangle(context, _p1, _p2, _p3);
  };

  return Triangle;

})(Drawable);

Circle = (function(_super) {
  __extends(Circle, _super);

  Circle.prototype.size = 20;

  function Circle(position) {
    this.position = position;
  }

  Circle.prototype.render = function(context) {
    return painter.drawCircle(context, this.position, this.size);
  };

  return Circle;

})(Drawable);

window.lastAdded = null;

Square = (function(_super) {
  __extends(Square, _super);

  Square.prototype.type = 'Square';

  Square.prototype.endPoint = null;

  Square.prototype.color = "black";

  Square.prototype.size = 15;

  function Square(position) {
    this.position = position;
    this.render = __bind(this.render, this);
    Square.__super__.constructor.apply(this, arguments);
  }

  Square.prototype.render = function(context) {
    return painter.fillCenteredRect(context, this.position, {
      x: this.size,
      y: this.size
    }, this.color, this.angle);
  };

  return Square;

})(Drawable);

Bot = (function(_super) {
  __extends(Bot, _super);

  Bot.prototype.type = 'Bot';

  Bot.prototype.color = 'red';

  Bot.prototype.multipliers = {
    'Bot': -2,
    'FixedPole': -1
  };

  Bot.prototype.size = 10;

  Bot.prototype.angularSpeed = .0001;

  function Bot(position) {
    this.position = position;
    Bot.__super__.constructor.apply(this, arguments);
    window.lastAdded = this;
  }

  Bot.prototype.tic = function(step) {
    Bot.__super__.tic.apply(this, arguments);
    if (this === window.lastAdded) {
      return console.log;
    }
  };

  return Bot;

})(Square);

FixedPole = (function(_super) {
  __extends(FixedPole, _super);

  function FixedPole() {
    _ref = FixedPole.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  FixedPole.prototype.color = "#08e";

  FixedPole.prototype.size = 50;

  FixedPole.prototype.tic = function(step) {
    return this.size = window.vars.polesize;
  };

  return FixedPole;

})(Circle);

Board = (function() {
  Board.prototype.addObject = function(object) {
    return this.state.push(object);
  };

  function Board(canvas) {
    var name, vars, _fn, _i, _len;
    this.canvas = canvas;
    window.context = this.canvas.getContext("2d");
    window.vars = {};
    vars = ['rest', 'polesize'];
    _fn = function() {
      var n,
        _this = this;
      n = name;
      return $(".control#" + name + " input").bind('change', function(event) {
        var value;
        window.e = event;
        value = Math.max(0.1, parseInt(event.target.value) / parseInt(event.target.dataset.divisor || 1));
        event.target.parentElement.querySelector('span').innerHTML = value;
        return window.vars[n] = value;
      });
    };
    for (_i = 0, _len = vars.length; _i < _len; _i++) {
      name = vars[_i];
      window.vars[name] = parseInt($(".control#" + name + " input").attr('value'));
      _fn();
    }
    this.state = [];
  }

  Board.prototype.render = function(context) {
    var item, _i, _len, _ref1, _results;
    _ref1 = this.state;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      _results.push(item.render(context));
    }
    return _results;
  };

  Board.prototype.tic = function(step) {
    var item, _i, _len, _ref1, _results;
    painter.fillRectangle(context, {
      x: 0,
      y: 0
    }, {
      x: this.canvas.width,
      y: this.canvas.height
    }, "rgba(255,255,255,.02)");
    _ref1 = this.state;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      item = _ref1[_i];
      _results.push(item.tic(step));
    }
    return _results;
  };

  return Board;

})();
